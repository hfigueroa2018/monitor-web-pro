<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>Dashboard Monitor Pro</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body{font-family:Arial,Helvetica,sans-serif;margin:40px;background:#f7f7f7;}
    h1,h2{color:#333;}
    .card{background:#fff;padding:20px;border-radius:8px;margin-bottom:20px;box-shadow:0 2px 4px rgba(0,0,0,.1);}
    .stat{font-size:24px;font-weight:bold;}
    .up{color:green}.down{color:red}
    table{width:100%;border-collapse:collapse;margin-top:10px;}
    th,td{padding:8px;border:1px solid #ccc;text-align:center;}
    th{background:#eee}
    canvas{height:300px}
    #chartContainer{position:relative;height:320px;width:100%}
    #responseChart{display:block;width:100% !important;height:100% !important}
    #progressBar{width:100%;background:#eee;border-radius:4px;margin:10px 0;}
    #progress{height:20px;background:#4caf50;width:0%;border-radius:4px;transition:width .2s}
    select,button{padding:6px 10px;margin-right:6px}
    :root{--bg:#f5f7fb;--card:#fff;--text:#333;--muted:#6b7280;--green:#2e7d32;--red:#c62828;--gray:#9ca3af;--shadow:0 2px 8px rgba(0,0,0,.06)}
    body{background:var(--bg)}
    .card{border:1px solid #e5e7eb;box-shadow:var(--shadow)}
    .card h2{margin:0 0 10px;font-size:18px;color:#111827}
    .kpis{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:16px;margin:16px 0 24px}
    .kpi{background:var(--card);border-radius:10px;box-shadow:var(--shadow);padding:14px 16px;display:flex;flex-direction:column;border:1px solid #e5e7eb}
    .kpi-title{color:var(--muted);font-size:12px;text-transform:uppercase;letter-spacing:.4px}
    .kpi-value{font-size:28px;font-weight:700;margin-top:4px;color:#111827}
    .kpi.up .kpi-value{color:var(--green)}
    .kpi.down .kpi-value{color:var(--red)}
    .kpi.unknown .kpi-value{color:var(--gray)}
    table thead th{background:#f3f4f6;font-weight:600}
    tbody tr:nth-child(odd){background:#fafafa}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script>
    window.__chartReady = (function() {
      let resolved = false;
      return new Promise((resolve) => {
        function done() { if (!resolved) { resolved = true; resolve(); } }
        if (window.Chart) return done();
        const alt = document.createElement('script');
        alt.src = 'https://unpkg.com/chart.js@4.4.1/dist/chart.umd.min.js';
        alt.onload = done;
        alt.onerror = done;
        document.head.appendChild(alt);
        setTimeout(done, 2000);
      });
    })();
  </script>
</head>
<body>
  <h1>Dashboard de Monitoreo</h1>
  <p>Welcome, {{ current_user.username }} | <a href="/logout">Logout</a></p>

  <div class="kpis">
    <div class="kpi up">
      <div class="kpi-title">Up</div>
      <div class="kpi-value" id="kpiUp">0</div>
    </div>
    <div class="kpi down">
      <div class="kpi-title">Down</div>
      <div class="kpi-value" id="kpiDown">0</div>
    </div>
    <div class="kpi unknown">
      <div class="kpi-title">Sin datos</div>
      <div class="kpi-value" id="kpiUnknown">0</div>
    </div>
    <div class="kpi">
      <div class="kpi-title">Disponibilidad 24h promedio</div>
      <div class="kpi-value" id="kpiAvail">0%</div>
    </div>
  </div>

  <!-- CONFIGURACIÓN -->
  <div class="card">
    <h2>Configuración</h2>
    <form id="configForm">
      <label>Frecuencia:
        <select id="freq">
          <option value="20">20 segundos</option>
          <option value="60">1 minuto</option>
          <option value="300">5 minutos</option>
          <option value="600">10 minutos</option>
          <option value="1800">30 minutos</option>
        </select>
      </label>
      <button type="button" id="btnStart">Iniciar monitoreo</button>
      <button type="button" id="btnStop">Detener monitoreo</button>
    </form>
    <p>Estado: <strong id="status">Detenido</strong></p>
  </div>

  <!-- AGREGAR SITIO -->
  <div class="card">
    <h2>Agregar sitio</h2>
    <form id="addForm">
      <input type="url" id="urlInput" placeholder="https://tusitio.com" required>
      <button type="submit">Agregar</button>
    </form>
  </div>

  <!-- TABLA DE SITIOS -->
  <div class="card">
    <h2>Sitios monitoreados</h2>
    <table>
      <thead>
        <tr><th>Sitio</th><th>Estado</th><th>Uptime 24h</th><th>Incidentes</th><th>Tiempo de respuesta</th><th>Acciones</th></tr>
      </thead>
      <tbody id="sitesTable"></tbody>
    </table>
  </div>

  <!-- GRÁFICO DE TIEMPOS DE RESPUESTA -->
  <div class="card">
    <h2>Tiempo de respuesta (última hora; si no hay datos, últimas 24h)</h2>
    <div id="chartContainer" style="position:relative;height:320px">
      <canvas id="responseChart"></canvas>
    </div>
    <p id="noData" style="display:none;color:#777;margin-top:8px">No hay sitios configurados. Agrega uno para ver gráficos.</p>
  </div>

  <!-- BARRA ANIMADA (oculta por defecto) -->
  <div id="progressBar" style="display:none;">
    <div id="progress"></div>
  </div>
  <p id="result"></p>

  <script>
    let responseChart;
    let refreshTimer;

    async function getSites() {
      const res = await fetch("/sites");
      return res.ok ? res.json() : [];
    }
    async function getMetrics(url, days = 1) {
      const res = await fetch(`/metrics/${encodeURIComponent(url)}?days=${days}`);
      return res.ok ? res.json() : { uptime: 0, incidents: 0, response: { avg: 0, min: 0, max: 0 } };
    }
    async function getSeries(url, minutes = 60) {
      const res = await fetch(`/response-series/${encodeURIComponent(url)}?minutes=${minutes}`);
      return res.ok ? res.json() : [];
    }
    function statusFromSeries(series){
      if(!series||series.length===0) return 'unknown';
      const last = series[series.length-1];
      if(!last) return 'unknown';
      if(typeof last.status === 'string') return last.status;
      return (last.value==null)?'down':'up';
    }

    async function checkSiteNow(url) {
      const bar = document.getElementById("progressBar");
      const prog = document.getElementById("progress");
      const resText = document.getElementById("result");
      bar.style.display = "block";
      prog.style.width = "0%";
      resText.textContent = "Revisando...";
      for (let i = 0; i <= 100; i += 10) {
        prog.style.width = i + "%";
        await new Promise(r => setTimeout(r, 100));
      }
      const resp = await fetch("/check", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ url })
      });
      const data = await resp.json();
      resText.textContent = data.message;
      prog.style.backgroundColor = data.status === "ok" ? "#4caf50" : "#f44336";
      setTimeout(() => { bar.style.display = "none"; loadAll(); }, 1000);
    }

    async function loadAll() {
      const sites = await getSites();
      const tbody = document.getElementById("sitesTable");
      tbody.innerHTML = "";
      const noDataEl = document.getElementById("noData");
      let upCount=0, downCount=0, unknownCount=0; let uptimeSum=0; let sitesCount=0;
      if (!sites || sites.length === 0) {
        if (responseChart) { responseChart.destroy(); responseChart = null; }
        if (noDataEl) noDataEl.style.display = "block";
        document.getElementById('kpiUp').textContent = '0';
        document.getElementById('kpiDown').textContent = '0';
        document.getElementById('kpiUnknown').textContent = '0';
        document.getElementById('kpiAvail').textContent = '0%';
        return;
      } else {
        if (noDataEl) noDataEl.style.display = "none";
      }

      // destruir gráfico anterior
      if (responseChart) responseChart.destroy();

      // construir datasets con series temporales
      const datasets = [];
      let labelsSet = new Set();

      for (const site of sites) {
        const url = site.url || site;
        const m   = await getMetrics(url, 1);
        const row = tbody.insertRow();
        row.innerHTML = `
          <td>${url}</td>
          <td class="${m.incidents ? 'down' : 'up'}">${m.incidents ? '❌ Down' : '✅ Up'}</td>
          <td>${m.uptime_percent}%</td>
          <td>${m.incidents}</td>
          <td>${m.response.avg} ms</td>
          <td><button onclick="checkSiteNow('${url}')">Probar</button></td>
        `;

        let seriesRaw = await getSeries(url, 60);
        if (!seriesRaw || seriesRaw.length === 0) {
          seriesRaw = await getSeries(url, 1440);
        }
        const currStatus = statusFromSeries(seriesRaw);
        if (currStatus === 'up') upCount++; else if (currStatus === 'down') downCount++; else unknownCount++;
        uptimeSum += Number(m && m.uptime_percent ? m.uptime_percent : 0);
        sitesCount++;
        let series = seriesRaw;
        if (!series || series.length === 0) {
          const nowTs = new Date().toISOString();
          const hasAvg = m && m.response && typeof m.response.avg === 'number' && m.response.avg > 0;
          series = [{ time: nowTs, value: hasAvg ? m.response.avg : null, status: hasAvg ? 'up' : 'down' }];
        }
        // recolectar labels (timestamps) únicos
        series.forEach(p => labelsSet.add(p.time));
        // mapas: up -> valor real, down -> 1ms para que sea visible
        const mapUp = series.reduce((acc, p) => (acc[p.time] = (p.value ?? null), acc), {});
        const mapDown = series.reduce((acc, p) => (acc[p.time] = (p.value == null ? 1 : null), acc), {});
        datasets.push({
          label: `${url} (UP)`,
          data: mapUp,
          borderWidth: 2,
          spanGaps: true,
          showLine: true,
          tension: 0.25,
          borderColor: '#2e7d32',
          backgroundColor: 'rgba(46,125,50,0.2)'
        });
        datasets.push({
          label: `${url} (DOWN)`,
          data: mapDown,
          borderWidth: 2,
          spanGaps: true,
          showLine: true,
          tension: 0.25,
          borderColor: '#c62828',
          backgroundColor: 'rgba(198,40,40,0.2)'
        });
      }

      // actualizar KPIs
      document.getElementById('kpiUp').textContent = String(upCount);
      document.getElementById('kpiDown').textContent = String(downCount);
      document.getElementById('kpiUnknown').textContent = String(unknownCount);
      const avgUptime = sitesCount>0 ? (uptimeSum/sitesCount).toFixed(1) : '0.0';
      document.getElementById('kpiAvail').textContent = `${avgUptime}%`;

      // ordenar labels cronológicamente
      const labels = Array.from(labelsSet).sort();

      // convertir datasets.data (mapa) a arreglo alineado con labels
      const chartDatasets = datasets.map(d => ({
        label: d.label,
        data: labels.map(ts => d.data[ts] ?? null),
        borderWidth: d.borderWidth,
        spanGaps: d.spanGaps ?? true,
        showLine: d.showLine ?? true,
        tension: d.tension ?? 0.25,
        fill: false,
        borderColor: d.borderColor,
        backgroundColor: d.backgroundColor,
        pointRadius: 3
      }));
      // filtrar datasets sin valores numéricos
      const hasVal = ds => ds.data.some(v => v !== null && !Number.isNaN(v));
      const finalDatasets = chartDatasets.filter(hasVal);
      if (finalDatasets.length === 0) {
        finalDatasets.push({
          label: 'Sin datos',
          data: labels.map(() => 0),
          borderWidth: 1,
          spanGaps: true,
          showLine: true,
          tension: 0.25,
          borderColor: '#999',
          backgroundColor: 'rgba(0,0,0,0.05)',
          pointRadius: 0
        });
      }

      const ctx = document.getElementById("responseChart");
      responseChart = new Chart(ctx, {
        type: "line",
        data: { labels, datasets: finalDatasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          elements: { point: { hitRadius: 10 } },
          interaction: { mode: 'nearest', intersect: false },
          plugins: { legend: { position: 'bottom' }, tooltip: { intersect: false } },
          scales: {
            y: { beginAtZero: true, title: { display: true, text: 'ms' } },
            x: { ticks: { autoSkip: true, maxTicksLimit: 8 } }
          }
        }
      });

      // refresco automático del gráfico cada 30s
      if (refreshTimer) clearInterval(refreshTimer);
      refreshTimer = setInterval(async () => {
        await refreshChart();
      }, 30000);
    }

    async function refreshChart() {
      const sites = await getSites();
      let labelsSet = new Set();
      const seriesByUrl = {};

      for (const site of sites) {
        const url = site.url || site;
        let series = await getSeries(url, 60);
        if (!series || series.length === 0) {
          series = await getSeries(url, 1440);
        }
        seriesByUrl[url] = series;
        series.forEach(p => labelsSet.add(p.time));
      }
      const labels = Array.from(labelsSet).sort();
      if (labels.length === 0) { return; }

      const newDatasets = (responseChart.data.datasets || []).map(ds => {
        // obtener URL base del label (quita sufijo " (UP)" o " (DOWN)")
        const urlBase = ds.label.replace(/ \(UP\)$| \(DOWN\)$/,'');
        const series = seriesByUrl[urlBase] || [];
        const mapUp = series.reduce((acc, p) => (acc[p.time] = (p.value ?? null), acc), {});
        const mapDown = series.reduce((acc, p) => (acc[p.time] = (p.value == null ? 1 : null), acc), {});
        const useMap = ds.label.endsWith('(DOWN)') ? mapDown : mapUp;
        return {
          ...ds,
          data: labels.map(ts => useMap[ts] ?? null)
        };
      });

      const filtered = newDatasets.filter(ds => ds.data.some(v => v !== null && !Number.isNaN(v)));
      responseChart.data.labels = labels;
      responseChart.data.datasets = filtered.length ? filtered : [{ label: 'Sin datos', data: labels.map(() => 0), borderWidth: 1, borderColor: '#999', backgroundColor: 'rgba(0,0,0,0.05)', pointRadius: 0 }];
      responseChart.update();
    }

    // ---------- CONFIG ----------
    document.getElementById("btnStart").onclick = async () => {
      const freq = document.getElementById("freq").value;
      await fetch("/config", { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded" }, body: `action=start&freq=${freq}` });
      document.getElementById("status").textContent = "Monitoreando";
    };
    document.getElementById("btnStop").onclick = async () => {
      await fetch("/config", { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded" }, body: "action=stop&freq=60" });
      document.getElementById("status").textContent = "Detenido";
      if (refreshTimer) clearInterval(refreshTimer);
    };

    // ---------- AGREGAR SITIO ----------
    document.getElementById("addForm").addEventListener("submit", async (e) => {
      e.preventDefault();
      const url = document.getElementById("urlInput").value.trim();
      if (!url) return;
      const res = await fetch("/add", { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded" }, body: `url=${encodeURIComponent(url)}` });
      if (res.ok) {
        document.getElementById("urlInput").value = "";
        await loadAll();
      } else {
        alert("Error al agregar sitio");
      }
    });

    // ---------- CARGA INICIAL ----------
    document.addEventListener('DOMContentLoaded', async () => {
      if (window.__chartReady) {
        await window.__chartReady;
      }
      loadAll();
    });
  </script>
</body>
</html>